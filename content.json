[{"title":"JavaScript 原型和原型链","date":"2017-11-16T02:30:59.000Z","path":"2017/11/16/JavaScript 原型和原型链/","text":"从原型到原型链构造函数创建对象123456function Person() &#123; &#125;var person = new Person();person.name = 'chenyn';console.log(person.name); 在这个例子中， Person 就是一个构造函数， person 是构造函数的实例 prototype每个函数都有一个 prototype 属性 12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = 'chenyn';var person1 = new Person();var person2 = new Person();console.log(person1.name) // chenynconsole.log(person2.name) // chenyn 函数的 prototype 属性指向了一个对象， 这个对象是调用该构造函数而创建的实例的原型，是例子中 person1、person2的原型 原型可以这样理解： 每一个 JavaScript 对象 （null 除外） 在创建的时候就会与另一个对象产生关联，这就是原型，每一个对象都会从原型’继承’属性 __proto__每个对象都有一个隐藏的属性—‘__proto__‘,这个属性指向了创建这个对象的函数的 prototype。 即: person.__proto__ = Person.prototype, 这个属性也被称为隐式原型 constructor每个原型都有一个 constructor 属性指向关联的构造函数，为什么没有指向实例的属性呢，因为实例可以有千千万万个。 12function Person () &#123;&#125;console.log(Person === Person.prototype.constructor) // true 关系图更新如上 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 实例与原型当读取实例属性时，会先从实例开始查找，如果查找不到，会向上往实例的原型中的属性找到，还没有，就去原型的原型中去找，一直到最顶层为止 1234567891011function Person() &#123; &#125;Person.prototype.name = 'chenyn'var person = new Person();person.name = 'beibei'console.log(person.name) // beibeidelete person.nameconsole.log(person.name) // chenyn 原型的原型原型也是一个对象，那么它就可以通过最原始的方法被创建 12var obj = new Object();obj.name = 'chen' 所以原型对象是通过 Object 构造函数生成的，实例的 proto 属性指向构造函数的 prototype属性，更新关系图 原型链那么 Object.prototype 的原型呢？ 1console.log(Object.prototype.__proto__ === null) // true null究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以可以理解为 Object.prototype 没有原型。 所以顺着原型的原型查找的时候，到 Object.prototype 就可以停止了 蓝色的这条线，其实就是大家老生常谈的原型链 tips真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 构造函数的 prototype 设置为 null 会怎样？1234567function Person() &#123; &#125;Person.prototype = null;var person = new Person()person.__proto__ === Person.prototype // falseperson.__proto__ === Object.prototype // true 首先new的时候 产生ECMA原生对象，接着此对象的[[Prototype]] 属性是根据 函数PERSTON的prototype来设定的，如果此时prototype是一个对象，[[Prototype]] =那个设定的对象,如果不是一个对象，设定 obj 的 [[Prototype]] 内部属性为 Object 的 prototype 对象 这个问题至今我没有找到合理的答案，上述是引自偶然看到的一个答案，仔细一想也是有道理的，实例是必然会有原型的，首先要明白null是为空的意思，即 Person.prototype 没有原型，那么没有原型我们怎么办呢，就给他设置为 Object.prototype 吧！感觉这个理解也说得过去，只是迟迟没有在 ECMA 或者某些权威的地方找到论证。 究极理解 这张经典的图，在很多教程上都出现过，理解了它，对于原型，原型链也就差不多了， 万物皆对象 函数都是有 Function() 创造的 Function.[[proto]] === Function.prototype 这件事，以后需要专门再一篇总结慢慢道来 文章 proto 与 prototye的关系 深入理解 Javascript 原型和闭包 JavaScript 深入之从原型到原型链","tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"http://yoursite.com/tags/JavaScript-基础/"}]},{"title":"详解 JavaScript 强制类型转换","date":"2017-11-14T06:52:59.000Z","path":"2017/11/14/详解 JavaScript 类型转换/","text":"运算符优先级 非常重要，下面很多地方需要用到 [] == [] 为什么是 false？数组是引用类型，是对地址的引用，虽然两个都为数组，但是在堆中的地址不同，所以比较结果为 false 为什么引用值要放在堆中，而原始值要放在栈中 记住一句话：能量是守衡的，无非是时间换空间，空间换时间的问题 堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。 详情请戳 理解JS内存分配 为什么 [] == false 而 !![] == true ？我们知道，非严格比较操作符 == 是会做强制类型转换的，根据 ECMA 标准，规则如下: If Type(y) is Boolean, return the result of the comparison x == ToNumber(y). If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y. [] == false所以 [] == false 的比较是对 x 执行 ToPrimitive, 然后和 ToNumber(false) 进行比较 12345678910111213141516171819202122232425ToPrimitive(obj,preferredType)JS引擎内部转换为原始值ToPrimitive(obj,preferredType)函数接受两个参数，第一个obj为被转换的对象，第二个preferredType为希望转换成的类型（默认为空，接受的值为Number或String）在执行ToPrimitive(obj,preferredType)时如果第二个参数为空并且obj为Date的事例时，此时preferredType会被设置为String，其他情况下preferredType都会被设置为Number如果preferredType为Number，ToPrimitive执行过程如下：1. 如果obj为原始值，直接返回；2. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；3. 否则调用 obj.toString()，如果执行结果是原始值，返回之；4. 否则抛异常。如果preferredType为String，将上面的第2步和第3步调换，即：1. 如果obj为原始值，直接返回；2. 否则调用 obj.toString()，如果执行结果是原始值，返回之；3. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；4. 否则抛异常. 所以对于 [], 先调用 [].valueOf() 返回的结果是 [],不是原始值，继续执行[].toString() 返回 &quot;&quot; 所以最终比较的是 &quot;&quot; == 0 结果为 true 代码实现 toPrimitive 方法12345678910111213141516171819202122232425262728293031323334353637const toPrimitive = (obj, preferredType='Number') =&gt; &#123; let Utils = &#123; typeOf: function(obj) &#123; return Object.prototype.toString.call(obj).slice(8, -1); &#125;, isPrimitive: function(obj) &#123; let types = ['Null', 'String', 'Boolean', 'Undefined', 'Number']; return types.indexOf(this.typeOf(obj)) !== -1; &#125; &#125;; if (Utils.isPrimitive(obj)) &#123; return obj; &#125; preferredType = (preferredType === 'String' || Utils.typeOf(obj) === 'Date') ? 'String' : 'Number'; if (preferredType === 'Number') &#123; if (Utils.isPrimitive(obj.valueOf())) &#123; return obj.valueOf() &#125;; if (Utils.isPrimitive(obj.toString())) &#123; return obj.toString() &#125;; &#125; else &#123; if (Utils.isPrimitive(obj.toString())) &#123; return obj.toString() &#125;; if (Utils.isPrimitive(obj.valueOf())) &#123; return obj.valueOf() &#125;; &#125;&#125;var a=&#123;&#125;;ToPrimitive(a);//\"[object Object]\",与上面文字分析的一致 !![] == true按照优先级， 会先执行 ! 按照上图规范，实际上执行 !!ToBoolean([]) 而 ToBoolean 的规则为 所以 ToBoolean([]) 为 true, !![]自然就为 true 了 这也是为什么我们不能用 if(!array) 来判断空数组而要用if(array.length === 0) 来判断空数组的原因。 valueOf() &amp;&amp; toString()上面提到了 valueOf() 和 toString() 两个方法，但具体为什么是那样的结果呢，鉴于待会最后一个案例还要用到，此时我们先来熟悉一下这两个方法。 toString()可以看做是把一个数据转换成了相应字符串的形式，按下图规则转换 当valueOf方法被调用时，会调用内置的ToObject，并将this作为参数传进去。ToObject检测会根据参数类型进行数值的转换： 123456Undefined - 抛出TypeError异常Null - 抛出TypeError异常Boolean - 创建一个Boolean对象，调用ToBoolean生成[[PrimitiveValue]]Number - 创建一个Number对象，调用ToNumber生成[[PrimitiveValue]]String - 创建一个String对象，调用ToString生成[[PrimitiveValue]]Object - 对象本身 加法中的隐式类型转换当计算表达式 value1 + value2 的时候，会按照如下规则: 将两个操作数转换为原始值 (下面是数学表示法,不是JavaScript代码): 12prim1 := ToPrimitive(value1)prim2 := ToPrimitive(value2) PreferredType 被省略,因此Date类型的值采用String,其他类型的值采用Number. 如果prim1或者prim2中的任意一个为字符串,则将另外一个也转换成字符串,然后返回两个字符串连接操作后的结果. 否则,将prim1和prim2都转换为数字类型,返回他们的和. 练习时间为了方便表达，x 表示左边的值， y 表示右边的值 [] == ![] 根据运算优先级, y 最终会变为 Boolean, 由前文图中可知，最后会变为 toPrimitive(x) == ToNumber(!ToBoolean(y)) 可知表达式为 true [] + [] 调用 toPrimitive，结果为 &quot;&quot; 123456789&gt; [] + &#123;&#125;&apos;[object Object]&apos;&gt; 5 + new Number(7)12&gt; 6 + &#123; valueOf: function () &#123; return 2 &#125; &#125;8&gt; &quot;abc&quot; + &#123; toString: function () &#123; return &quot;def&quot; &#125; &#125;&apos;abcdef&apos;此上都是对于加号运算的规则分析得出的结果 {} + {} 结果为 NaN， 这是为什么呢？浏览器在解析时，会把第一个{}解释为一个空代码块，并忽略他，实为执行 +{},这里的 + 是一元操作符，作用是将它后面的操作数转为数字,过程如下 12345+&#123;&#125;Number(&#123;&#125;)Number(&#123;&#125;.toString()) // 因为&#123;&#125;.valueOf()不是原始值Number(&quot;[object Object]&quot;)NaN // 结果为 NaN true + 1，这个要着重记录一下，因为看到的时候是百思不得姐，为什么是 2 呢，后来仔细去看 toPrimitive 因为 true 是原始值，所以直接返回 true，所以 左右有一为 Number，执行 ToNumber(true)得出结果为2 总结1234567891011我们总结一下==运算的规则：1. undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。2. String == Boolean，需要两个操作数同时转为Number。3. String/Boolean == Number，需要String/Boolean转为Number。4. Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)。瞧见没有，一共只有4条规则！是不是很清晰、很简单。 参考文章 关于原生 JS 的一些研究 what is {} + {} in JavaScript JavaScript中加号运算符的类型转换优先级是什么？ JS中{}+[]和[]+{}的返回值情况是怎样的？ [译]JavaScript中,{}+{}等于多少?","tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"http://yoursite.com/tags/JavaScript-基础/"}]},{"title":"你不知道的 JS --- 类型","date":"2017-10-24T06:52:59.000Z","path":"2017/10/24/你不懂js_类型/","text":"基础的牢固对于阅读源码等有很大的帮助 typeof 的 “安全防御行为”123if (typeof atob === \"undefined\") &#123; atob = function() &#123; /*..*/ &#125;;&#125; 此处如果在if语句中用var变量声明atob，则会造成变量提升，即使没有走if语句。(参见作用域与闭包)123var a = trueif(!a) &#123;e= 2&#125;else &#123;c = 1&#125; 打印e 会输出 ReferenceError: e is not defined而如果123var a = trueif(!a) &#123;var e= 2&#125;else &#123;c = 1&#125; 输出的为undefined 变量被提升了","tags":[{"name":"你不懂js","slug":"你不懂js","permalink":"http://yoursite.com/tags/你不懂js/"}]},{"title":"Object.defineProperty","date":"2017-02-27T01:09:16.000Z","path":"2017/02/27/Object-defineProperty/","text":"gettter 和 setter","tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/tags/vue-js/"},{"name":"数据双向绑定","slug":"数据双向绑定","permalink":"http://yoursite.com/tags/数据双向绑定/"},{"name":"vue.js原理","slug":"vue-js原理","permalink":"http://yoursite.com/tags/vue-js原理/"}]},{"title":"vue学习笔记-1","date":"2017-02-24T13:58:58.000Z","path":"2017/02/24/vue学习笔记-1/","text":"今晚那该死的贝贝居然弃我而去，上了别人的床。俗话说的好，爱上一个不回家的人，有啥不一样！苦逼的程序猿只能继续敲代码了。 vue和react同时学习进行了一段时间后，还是准备先系统的学习一下vue，原因很简单，vue的官方文档友好太多,而且网上有太多的demo可以练习。 一、 VUE简介 Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue.js 是用于构建交互式的 Web 界面的库。Vue.js 提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。 Vue.js 特点 简洁： HTML 模板 + JSON 数据，再创建一个 Vue 实例，就这么简单。 数据驱动： 自动追踪依赖的模板表达式和计算属性。 组件化： 用解耦、可复用的组件来构造界面。 轻量： ~24kb min+gzip，无依赖。 快速： 精确有效的异步批量 DOM 更新。 模块友好： 通过 NPM 或 Bower 安装，无缝融入你的工作流。 喜欢vue的理由 可扩展的数据绑定机制 原生对象即模型 简洁明了的 API 组件化 UI 构建 多个轻量库搭配使用 vue起手式vue-cli脚手架: 官网介绍安装 vue-cli安装 下拉到命令行全局安装vue-cli npm install -g vue-cli 或 npm install –global vue-cli 初始化项目 vue init webpack vuedemo(你的项目名) 会出现提问，一路回车即可。随后 $ cd vuedemo(你的项目名) 安装webpack依赖 npm install npm镜像一般要换成淘宝镜像 npm install -g cnpm –registry=http://registry.npm.taobao.org 安装完成后,把项目跑起来: npm run dev 如上四个命令，就会自动打开一个浏览器窗口，你的第一个vue项目就跑起来。你编写的代码的时候，ctrl+s浏览器窗口会自动刷新 项目完成后，可以打包成线上包，指令为 npm run build","tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/tags/vue-js/"},{"name":"前端小镇","slug":"前端小镇","permalink":"http://yoursite.com/tags/前端小镇/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]},{"title":"移动端踩坑实践","date":"2017-02-24T06:52:59.000Z","path":"2017/02/24/移动端踩坑实践/","text":"去年十一月份接手了一个项目,移动端webapp,已经经历了长达四个月的开发,迭代,维护。特此记录下实践过程中的坑,方便以后查阅。如有不对，请指正，谢谢！ ios端关于date() 兼容性问题 项目中有一关于返回的时间与某一时间戳对比的问题,时间戳返回的为数字,而时间返回的是 ‘2017-02-24 14:58:32’形式用,最开始使用的方法为: 1var dTime = (new Date(time)).getTime(); 但实际过程中发现ios端对此返回的是NaN.解决方案为: 1dTime = dTime.replace(/\\-/g, \"/\"); Android,Ios共用的是此种形式: 1var date =new Date(\"2016/05/31 08:00\"); 所以使用正则调整为两者皆可的形式即可。 Html5日历控件赋值问题 HTML5中新增了日历控件，如果将控件的type=“datetime-local”，如果是Chrome，控件的日期显示格式是2016/05/30 08:00 ，如果是Safari，日期的显示格式是：2016-05-31T08:00，当我们用jQuery取值赋值的时候，就必须用这种方式才能赋值： 12let dTime = '2016-05-30T08:30'$(\"#timeDate\").val(dTime) 抽空继续总结，未完待续…","tags":[{"name":"前端小镇","slug":"前端小镇","permalink":"http://yoursite.com/tags/前端小镇/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"iframe父子页面通信实现","date":"2017-02-23T14:11:08.000Z","path":"2017/02/23/iframe父子页面通信实现/","text":"近来有一需求，即在PC端erp内嵌移动官网，通过iframe来实现嵌套的，但是又需要实现在父页面添加prev，next按钮，最后通过设置页面简单路由的方式来解决了。借此，系统学了下iframe父子页面通信。 一、 同域下父子页面通信 先来看具体实现 parent.html 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\"&gt; function say()&#123; alert(\"parent.html\"); &#125; function callChild()&#123; myFrame.window.say(); myFrame.window.document.getElementById(\"button\").value=\"调用结束\"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=\"button\" type=\"button\" value=\"调用child.html中的函数say()\" onclick=\"callChild()\"/&gt; &lt;iframe name=\"myFrame\" src=\"child.html\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 未完待续…","tags":[{"name":"iframe","slug":"iframe","permalink":"http://yoursite.com/tags/iframe/"},{"name":"router","slug":"router","permalink":"http://yoursite.com/tags/router/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]}]