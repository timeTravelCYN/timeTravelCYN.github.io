[{"title":"Vue 父子组件通信之 v-model","date":"2018-03-11T06:52:59.000Z","path":"2018/03/11/Vue 父子组件通信之  v-model/","text":"北京最近的天，可真是热啊 Vue 组件间通信Vue 组件间通信是个老生常谈的问题，在开发中几乎必定会遇到。下面我们先来谈一下基本的通信方法 父传子 props $children子传父 父组件传递函数给子组件，子组件通过 $emit 触发 修改父组件的 props 通过 $parent 访问父组件兄弟组件 EventBus 当然了，你也可以用 vuex 解决一切 今天就来谈一种平时不经常用的通信方式， v-model 通过 v-model 进行父子组件通信 我们先用传统的方式来实现组件通信父组件:1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=\"parent\"&gt; &lt;child :index=\"index\" @decrease=\"decrease\"&gt;&lt;/child&gt; &lt;button @click=\"increase\"&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Child from './child' export default &#123; name: 'parent', components: &#123; Child &#125;, data() &#123; return &#123; index: 0 &#125; &#125;, methods: &#123; increase () &#123; this.index++ &#125;, decrease () &#123; this.index-- &#125; &#125; &#125;&lt;/script&gt; 子组件:1234567891011121314151617181920&lt;template&gt; &lt;div class=\"child\"&gt; &lt;div&gt;&#123;&#123; index &#125;&#125;&lt;/div&gt; &lt;button @click=\"decrease\"&gt;减少&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'child', props: &#123; index: Number &#125;, methods: &#123; decrease: function () &#123; this.$emit('decrease') &#125; &#125; &#125;&lt;/script&gt; 这是平时用到比较多的一种方式。 v-model 父子通信那么，如果用 v-model 是什么样的呢？ 先来看代码12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=\"parent\"&gt; &lt;child v-model=\"index\"&gt;&lt;/child&gt; &lt;button @click=\"increase\"&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Child from './child' export default &#123; components: &#123; Child &#125;, data() &#123; return &#123; index: 0 &#125; &#125;, methods: &#123; increase () &#123; this.index++ &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516171819&lt;template&gt; &lt;div class=\"child\"&gt; &lt;div&gt;&#123;&#123; value &#125;&#125;&lt;/div&gt; &lt;button @click=\"decrease\"&gt;减少&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; value: Number &#125;, methods: &#123; decrease: function () &#123; this.$emit('input', this.value - 1) &#125; &#125; &#125;&lt;/script&gt; 是不是比之前的实现方式简便了许多呢？ 原理解析&lt;child v-model=&quot;index&quot;&gt;&lt;/child&gt; 实际上是 &lt;input v-on:input=&quot;index = arguments[0]&quot; :value=&quot;index&quot;&gt; 这样是不是就好理解了？ v-model 实际上是个语法糖1&lt;input v-model=\"searchText\"&gt; 等价于1234&lt;input v-bind:value=\"searchText\" v-on:input=\"searchText = $event.target.value\"&gt; 当作用在组件上时 123&lt;custon-input v-bind:value=\"something\" v-on:input=\"something=arguments[0]\"&gt;&lt;/custom-input&gt; 所以要让组件的 v-model 生效，它应该： 接受一个 value 属性 在 value 变化时触发 input 事件 父子通信，还有一种 .sync 的方法， 跟 v-model 差不多，官方更推荐用 .sync 多一些","tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/tags/vue-js/"}]},{"title":"可编辑 div 光标设置","date":"2017-12-11T11:34:20.000Z","path":"2017/12/11/work-- 可编辑 div 光标设置在最后/","text":"场景在做公司食谱编辑的时候，涉及到表头的编辑，使用的是 contenteditable属性，但是在让他自动聚焦的时候出现了问题，光标出现在了最前面。 查阅了资料后，解决，实际效果如下 12345678910111213141516171819202122function set_focus(el) &#123; //el=el[0]; //jquery 对象转dom对象 el.focus(); if($.support.msie) &#123; var range = document.selection.createRange(); this.last = range; range.moveToElementText(el); range.select(); document.selection.empty(); //取消选中 &#125; else &#123; var range = document.createRange(); range.selectNodeContents(el); range.collapse(false); var sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); &#125; &#125; 参考资料Set focus on div contenteditable elementSet cursor position on contentEditable 可编辑div将光标放在最后","tags":[{"name":"工作实际问题","slug":"工作实际问题","permalink":"http://yoursite.com/tags/工作实际问题/"}]},{"title":"JavaScript 原型和原型链","date":"2017-11-16T02:30:59.000Z","path":"2017/11/16/JavaScript 原型和原型链/","text":"从原型到原型链构造函数创建对象123456function Person() &#123; &#125;var person = new Person();person.name = 'chenyn';console.log(person.name); 在这个例子中， Person 就是一个构造函数， person 是构造函数的实例 prototype每个函数都有一个 prototype 属性 12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = 'chenyn';var person1 = new Person();var person2 = new Person();console.log(person1.name) // chenynconsole.log(person2.name) // chenyn 函数的 prototype 属性指向了一个对象， 这个对象是调用该构造函数而创建的实例的原型，是例子中 person1、person2的原型 原型可以这样理解： 每一个 JavaScript 对象 （null 除外） 在创建的时候就会与另一个对象产生关联，这就是原型，每一个对象都会从原型’继承’属性 __proto__每个对象都有一个隐藏的属性—‘__proto__‘,这个属性指向了创建这个对象的函数的 prototype。 即: person.__proto__ = Person.prototype, 这个属性也被称为隐式原型 constructor每个原型都有一个 constructor 属性指向关联的构造函数，为什么没有指向实例的属性呢，因为实例可以有千千万万个。 12function Person () &#123;&#125;console.log(Person === Person.prototype.constructor) // true 关系图更新如上 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 实例与原型当读取实例属性时，会先从实例开始查找，如果查找不到，会向上往实例的原型中的属性找到，还没有，就去原型的原型中去找，一直到最顶层为止 1234567891011function Person() &#123; &#125;Person.prototype.name = 'chenyn'var person = new Person();person.name = 'beibei'console.log(person.name) // beibeidelete person.nameconsole.log(person.name) // chenyn 原型的原型原型也是一个对象，那么它就可以通过最原始的方法被创建 12var obj = new Object();obj.name = 'chen' 所以原型对象是通过 Object 构造函数生成的，实例的 proto 属性指向构造函数的 prototype属性，更新关系图 原型链那么 Object.prototype 的原型呢？ 1console.log(Object.prototype.__proto__ === null) // true null究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以可以理解为 Object.prototype 没有原型。 所以顺着原型的原型查找的时候，到 Object.prototype 就可以停止了 蓝色的这条线，其实就是大家老生常谈的原型链 tips真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 构造函数的 prototype 设置为 null 会怎样？1234567function Person() &#123; &#125;Person.prototype = null;var person = new Person()person.__proto__ === Person.prototype // falseperson.__proto__ === Object.prototype // true 首先new的时候 产生ECMA原生对象，接着此对象的[[Prototype]] 属性是根据 函数PERSTON的prototype来设定的，如果此时prototype是一个对象，[[Prototype]] =那个设定的对象,如果不是一个对象，设定 obj 的 [[Prototype]] 内部属性为 Object 的 prototype 对象 这个问题至今我没有找到合理的答案，上述是引自偶然看到的一个答案，仔细一想也是有道理的，实例是必然会有原型的，首先要明白null是为空的意思，即 Person.prototype 没有原型，那么没有原型我们怎么办呢，就给他设置为 Object.prototype 吧！感觉这个理解也说得过去，只是迟迟没有在 ECMA 或者某些权威的地方找到论证。 究极理解 这张经典的图，在很多教程上都出现过，理解了它，对于原型，原型链也就差不多了， 万物皆对象 函数都是有 Function() 创造的 Function.[[proto]] === Function.prototype 这件事，以后需要专门再一篇总结慢慢道来 文章 proto 与 prototye的关系 深入理解 Javascript 原型和闭包 JavaScript 深入之从原型到原型链","tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"http://yoursite.com/tags/JavaScript-基础/"}]},{"title":"详解 JavaScript 强制类型转换","date":"2017-11-14T06:52:59.000Z","path":"2017/11/14/详解 JavaScript 类型转换/","text":"运算符优先级 非常重要，下面很多地方需要用到 [] == [] 为什么是 false？数组是引用类型，是对地址的引用，虽然两个都为数组，但是在堆中的地址不同，所以比较结果为 false 为什么引用值要放在堆中，而原始值要放在栈中 记住一句话：能量是守衡的，无非是时间换空间，空间换时间的问题 堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。 详情请戳 理解JS内存分配 为什么 [] == false 而 !![] == true ？我们知道，非严格比较操作符 == 是会做强制类型转换的，根据 ECMA 标准，规则如下: If Type(y) is Boolean, return the result of the comparison x == ToNumber(y). If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y. [] == false所以 [] == false 的比较是对 x 执行 ToPrimitive, 然后和 ToNumber(false) 进行比较 12345678910111213141516171819202122232425ToPrimitive(obj,preferredType)JS引擎内部转换为原始值ToPrimitive(obj,preferredType)函数接受两个参数，第一个obj为被转换的对象，第二个preferredType为希望转换成的类型（默认为空，接受的值为Number或String）在执行ToPrimitive(obj,preferredType)时如果第二个参数为空并且obj为Date的事例时，此时preferredType会被设置为String，其他情况下preferredType都会被设置为Number如果preferredType为Number，ToPrimitive执行过程如下：1. 如果obj为原始值，直接返回；2. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；3. 否则调用 obj.toString()，如果执行结果是原始值，返回之；4. 否则抛异常。如果preferredType为String，将上面的第2步和第3步调换，即：1. 如果obj为原始值，直接返回；2. 否则调用 obj.toString()，如果执行结果是原始值，返回之；3. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；4. 否则抛异常. 所以对于 [], 先调用 [].valueOf() 返回的结果是 [],不是原始值，继续执行[].toString() 返回 &quot;&quot; 所以最终比较的是 &quot;&quot; == 0 结果为 true 代码实现 toPrimitive 方法12345678910111213141516171819202122232425262728293031323334353637const toPrimitive = (obj, preferredType='Number') =&gt; &#123; let Utils = &#123; typeOf: function(obj) &#123; return Object.prototype.toString.call(obj).slice(8, -1); &#125;, isPrimitive: function(obj) &#123; let types = ['Null', 'String', 'Boolean', 'Undefined', 'Number']; return types.indexOf(this.typeOf(obj)) !== -1; &#125; &#125;; if (Utils.isPrimitive(obj)) &#123; return obj; &#125; preferredType = (preferredType === 'String' || Utils.typeOf(obj) === 'Date') ? 'String' : 'Number'; if (preferredType === 'Number') &#123; if (Utils.isPrimitive(obj.valueOf())) &#123; return obj.valueOf() &#125;; if (Utils.isPrimitive(obj.toString())) &#123; return obj.toString() &#125;; &#125; else &#123; if (Utils.isPrimitive(obj.toString())) &#123; return obj.toString() &#125;; if (Utils.isPrimitive(obj.valueOf())) &#123; return obj.valueOf() &#125;; &#125;&#125;var a=&#123;&#125;;ToPrimitive(a);//\"[object Object]\",与上面文字分析的一致 !![] == true按照优先级， 会先执行 ! 按照上图规范，实际上执行 !!ToBoolean([]) 而 ToBoolean 的规则为 所以 ToBoolean([]) 为 true, !![]自然就为 true 了 这也是为什么我们不能用 if(!array) 来判断空数组而要用if(array.length === 0) 来判断空数组的原因。 valueOf() &amp;&amp; toString()上面提到了 valueOf() 和 toString() 两个方法，但具体为什么是那样的结果呢，鉴于待会最后一个案例还要用到，此时我们先来熟悉一下这两个方法。 toString()可以看做是把一个数据转换成了相应字符串的形式，按下图规则转换 当valueOf方法被调用时，会调用内置的ToObject，并将this作为参数传进去。ToObject检测会根据参数类型进行数值的转换： 123456Undefined - 抛出TypeError异常Null - 抛出TypeError异常Boolean - 创建一个Boolean对象，调用ToBoolean生成[[PrimitiveValue]]Number - 创建一个Number对象，调用ToNumber生成[[PrimitiveValue]]String - 创建一个String对象，调用ToString生成[[PrimitiveValue]]Object - 对象本身 加法中的隐式类型转换当计算表达式 value1 + value2 的时候，会按照如下规则: 将两个操作数转换为原始值 (下面是数学表示法,不是JavaScript代码): 12prim1 := ToPrimitive(value1)prim2 := ToPrimitive(value2) PreferredType 被省略,因此Date类型的值采用String,其他类型的值采用Number. 如果prim1或者prim2中的任意一个为字符串,则将另外一个也转换成字符串,然后返回两个字符串连接操作后的结果. 否则,将prim1和prim2都转换为数字类型,返回他们的和. 练习时间为了方便表达，x 表示左边的值， y 表示右边的值 [] == ![] 根据运算优先级, y 最终会变为 Boolean, 由前文图中可知，最后会变为 toPrimitive(x) == ToNumber(!ToBoolean(y)) 可知表达式为 true [] + [] 调用 toPrimitive，结果为 &quot;&quot; 123456789&gt; [] + &#123;&#125;&apos;[object Object]&apos;&gt; 5 + new Number(7)12&gt; 6 + &#123; valueOf: function () &#123; return 2 &#125; &#125;8&gt; &quot;abc&quot; + &#123; toString: function () &#123; return &quot;def&quot; &#125; &#125;&apos;abcdef&apos;此上都是对于加号运算的规则分析得出的结果 {} + {} 结果为 NaN， 这是为什么呢？浏览器在解析时，会把第一个{}解释为一个空代码块，并忽略他，实为执行 +{},这里的 + 是一元操作符，作用是将它后面的操作数转为数字,过程如下 12345+&#123;&#125;Number(&#123;&#125;)Number(&#123;&#125;.toString()) // 因为&#123;&#125;.valueOf()不是原始值Number(&quot;[object Object]&quot;)NaN // 结果为 NaN true + 1，这个要着重记录一下，因为看到的时候是百思不得姐，为什么是 2 呢，后来仔细去看 toPrimitive 因为 true 是原始值，所以直接返回 true，所以 左右有一为 Number，执行 ToNumber(true)得出结果为2 总结1234567891011我们总结一下==运算的规则：1. undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。2. String == Boolean，需要两个操作数同时转为Number。3. String/Boolean == Number，需要String/Boolean转为Number。4. Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)。瞧见没有，一共只有4条规则！是不是很清晰、很简单。 参考文章 关于原生 JS 的一些研究 what is {} + {} in JavaScript JavaScript中加号运算符的类型转换优先级是什么？ JS中{}+[]和[]+{}的返回值情况是怎样的？ [译]JavaScript中,{}+{}等于多少?","tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"http://yoursite.com/tags/JavaScript-基础/"}]},{"title":"你不知道的 JS --- 类型","date":"2017-10-24T06:52:59.000Z","path":"2017/10/24/你不懂js_类型/","text":"基础的牢固对于阅读源码等有很大的帮助 typeof 的 “安全防御行为”123if (typeof atob === \"undefined\") &#123; atob = function() &#123; /*..*/ &#125;;&#125; 此处如果在if语句中用var变量声明atob，则会造成变量提升，即使没有走if语句。(参见作用域与闭包)123var a = trueif(!a) &#123;e= 2&#125;else &#123;c = 1&#125; 打印e 会输出 ReferenceError: e is not defined而如果123var a = trueif(!a) &#123;var e= 2&#125;else &#123;c = 1&#125; 输出的为undefined 变量被提升了","tags":[{"name":"你不懂js","slug":"你不懂js","permalink":"http://yoursite.com/tags/你不懂js/"}]},{"title":"Object.defineProperty","date":"2017-02-27T01:09:16.000Z","path":"2017/02/27/Object-defineProperty/","text":"gettter 和 setter","tags":[{"name":"数据双向绑定","slug":"数据双向绑定","permalink":"http://yoursite.com/tags/数据双向绑定/"},{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/tags/vue-js/"},{"name":"vue.js原理","slug":"vue-js原理","permalink":"http://yoursite.com/tags/vue-js原理/"}]},{"title":"移动端踩坑实践","date":"2017-02-24T06:52:59.000Z","path":"2017/02/24/移动端踩坑实践/","text":"去年十一月份接手了一个项目,移动端webapp,已经经历了长达四个月的开发,迭代,维护。特此记录下实践过程中的坑,方便以后查阅。如有不对，请指正，谢谢！ ios端关于date() 兼容性问题 项目中有一关于返回的时间与某一时间戳对比的问题,时间戳返回的为数字,而时间返回的是 ‘2017-02-24 14:58:32’形式用,最开始使用的方法为: 1var dTime = (new Date(time)).getTime(); 但实际过程中发现ios端对此返回的是NaN.解决方案为: 1dTime = dTime.replace(/\\-/g, \"/\"); Android,Ios共用的是此种形式: 1var date =new Date(\"2016/05/31 08:00\"); 所以使用正则调整为两者皆可的形式即可。 Html5日历控件赋值问题 HTML5中新增了日历控件，如果将控件的type=“datetime-local”，如果是Chrome，控件的日期显示格式是2016/05/30 08:00 ，如果是Safari，日期的显示格式是：2016-05-31T08:00，当我们用jQuery取值赋值的时候，就必须用这种方式才能赋值： 12let dTime = '2016-05-30T08:30'$(\"#timeDate\").val(dTime) 抽空继续总结，未完待续…","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]}]