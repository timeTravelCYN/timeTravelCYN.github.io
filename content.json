[{"title":"详解 JavaScript 强制类型转换","date":"2017-11-14T06:52:59.000Z","path":"2017/11/14/详解 JavaScript 类型转换/","text":"详解 JavaScript 强制类型转换运算符优先级 非常重要，下面很多地方需要用到 [] == [] 为什么是 false？数组是引用类型，是对地址的引用，虽然两个都为数组，但是在堆中的地址不同，所以比较结果为 false 为什么引用值要放在堆中，而原始值要放在栈中 记住一句话：能量是守衡的，无非是时间换空间，空间换时间的问题 堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。 详情请戳 理解JS内存分配 为什么 [] == false 而 !![] == true ？我们知道，非严格比较操作符 == 是会做强制类型转换的，根据 ECMA 标准，规则如下: If Type(y) is Boolean, return the result of the comparison x == ToNumber(y). If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y. [] == false所以 [] == false 的比较是对 x 执行 ToPrimitive, 然后和 ToNumber(false) 进行比较 12345678910111213141516171819202122232425ToPrimitive(obj,preferredType)JS引擎内部转换为原始值ToPrimitive(obj,preferredType)函数接受两个参数，第一个obj为被转换的对象，第二个preferredType为希望转换成的类型（默认为空，接受的值为Number或String）在执行ToPrimitive(obj,preferredType)时如果第二个参数为空并且obj为Date的事例时，此时preferredType会被设置为String，其他情况下preferredType都会被设置为Number如果preferredType为Number，ToPrimitive执行过程如下：1. 如果obj为原始值，直接返回；2. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；3. 否则调用 obj.toString()，如果执行结果是原始值，返回之；4. 否则抛异常。如果preferredType为String，将上面的第2步和第3步调换，即：1. 如果obj为原始值，直接返回；2. 否则调用 obj.toString()，如果执行结果是原始值，返回之；3. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；4. 否则抛异常. 所以对于 [], 先调用 [].valueOf() 返回的结果是 [],不是原始值，继续执行[].toString() 返回 &quot;&quot; 所以最终比较的是 &quot;&quot; == 0 结果为 true 代码实现 toPrimitive 方法12345678910111213141516171819202122232425262728293031323334353637const toPrimitive = (obj, preferredType='Number') =&gt; &#123; let Utils = &#123; typeOf: function(obj) &#123; return Object.prototype.toString.call(obj).slice(8, -1); &#125;, isPrimitive: function(obj) &#123; let types = ['Null', 'String', 'Boolean', 'Undefined', 'Number']; return types.indexOf(this.typeOf(obj)) !== -1; &#125; &#125;; if (Utils.isPrimitive(obj)) &#123; return obj; &#125; preferredType = (preferredType === 'String' || Utils.typeOf(obj) === 'Date') ? 'String' : 'Number'; if (preferredType === 'Number') &#123; if (Utils.isPrimitive(obj.valueOf())) &#123; return obj.valueOf() &#125;; if (Utils.isPrimitive(obj.toString())) &#123; return obj.toString() &#125;; &#125; else &#123; if (Utils.isPrimitive(obj.toString())) &#123; return obj.toString() &#125;; if (Utils.isPrimitive(obj.valueOf())) &#123; return obj.valueOf() &#125;; &#125;&#125;var a=&#123;&#125;;ToPrimitive(a);//\"[object Object]\",与上面文字分析的一致 !![] == true按照优先级， 会先执行 ! 按照上图规范，实际上执行 !!ToBoolean([]) 而 ToBoolean 的规则为 所以 ToBoolean([]) 为 true, !![]自然就为 true 了 这也是为什么我们不能用 if(!array) 来判断空数组而要用if(array.length === 0) 来判断空数组的原因。 valueOf() &amp;&amp; toString()上面提到了 valueOf() 和 toString() 两个方法，但具体为什么是那样的结果呢，鉴于待会最后一个案例还要用到，此时我们先来熟悉一下这两个方法。 toString()可以看做是把一个数据转换成了相应字符串的形式，按下图规则转换 当valueOf方法被调用时，会调用内置的ToObject，并将this作为参数传进去。ToObject检测会根据参数类型进行数值的转换： 123456Undefined - 抛出TypeError异常Null - 抛出TypeError异常Boolean - 创建一个Boolean对象，调用ToBoolean生成[[PrimitiveValue]]Number - 创建一个Number对象，调用ToNumber生成[[PrimitiveValue]]String - 创建一个String对象，调用ToString生成[[PrimitiveValue]]Object - 对象本身 加法中的隐式类型转换当计算表达式 value1 + value2 的时候，会按照如下规则: 将两个操作数转换为原始值 (下面是数学表示法,不是JavaScript代码): 12prim1 := ToPrimitive(value1)prim2 := ToPrimitive(value2) PreferredType 被省略,因此Date类型的值采用String,其他类型的值采用Number. 如果prim1或者prim2中的任意一个为字符串,则将另外一个也转换成字符串,然后返回两个字符串连接操作后的结果. 否则,将prim1和prim2都转换为数字类型,返回他们的和. 练习时间为了方便表达，x 表示左边的值， y 表示右边的值 [] == ![] 根据运算优先级, y 最终会变为 Boolean, 由前文图中可知，最后会变为 toPrimitive(x) == ToNumber(!ToBoolean(y)) 可知表达式为 true [] + [] 调用 toPrimitive，结果为 &quot;&quot; 123456789&gt; [] + &#123;&#125;&apos;[object Object]&apos;&gt; 5 + new Number(7)12&gt; 6 + &#123; valueOf: function () &#123; return 2 &#125; &#125;8&gt; &quot;abc&quot; + &#123; toString: function () &#123; return &quot;def&quot; &#125; &#125;&apos;abcdef&apos;此上都是对于加号运算的规则分析得出的结果 {} + {} 结果为 NaN， 这是为什么呢？浏览器在解析时，会把第一个{}解释为一个空代码块，并忽略他，实为执行 +{},这里的 + 是一元操作符，作用是将它后面的操作数转为数字,过程如下 12345+&#123;&#125;Number(&#123;&#125;)Number(&#123;&#125;.toString()) // 因为&#123;&#125;.valueOf()不是原始值Number(&quot;[object Object]&quot;)NaN // 结果为 NaN true + 1，这个要着重记录一下，因为看到的时候是百思不得姐，为什么是 2 呢，后来仔细去看 toPrimitive 因为 true 是原始值，所以直接返回 true，所以 左右有一为 Number，执行 ToNumber(true)得出结果为2 总结1234567891011我们总结一下==运算的规则：1. undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。2. String == Boolean，需要两个操作数同时转为Number。3. String/Boolean == Number，需要String/Boolean转为Number。4. Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)。瞧见没有，一共只有4条规则！是不是很清晰、很简单。 参考文章 关于原生 JS 的一些研究 what is {} + {} in JavaScript JavaScript中加号运算符的类型转换优先级是什么？ JS中{}+[]和[]+{}的返回值情况是怎样的？ [译]JavaScript中,{}+{}等于多少?","tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"http://yoursite.com/tags/JavaScript-基础/"}]},{"title":"Object.defineProperty","date":"2017-02-27T01:09:16.000Z","path":"2017/02/27/Object-defineProperty/","text":"gettter 和 setter","tags":[{"name":"数据双向绑定","slug":"数据双向绑定","permalink":"http://yoursite.com/tags/数据双向绑定/"},{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/tags/vue-js/"},{"name":"vue.js原理","slug":"vue-js原理","permalink":"http://yoursite.com/tags/vue-js原理/"}]},{"title":"vue学习笔记-1","date":"2017-02-24T13:58:58.000Z","path":"2017/02/24/vue学习笔记-1/","text":"今晚那该死的贝贝居然弃我而去，上了别人的床。俗话说的好，爱上一个不回家的人，有啥不一样！苦逼的程序猿只能继续敲代码了。 vue和react同时学习进行了一段时间后，还是准备先系统的学习一下vue，原因很简单，vue的官方文档友好太多,而且网上有太多的demo可以练习。 一、 VUE简介 Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue.js 是用于构建交互式的 Web 界面的库。Vue.js 提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。 Vue.js 特点 简洁： HTML 模板 + JSON 数据，再创建一个 Vue 实例，就这么简单。 数据驱动： 自动追踪依赖的模板表达式和计算属性。 组件化： 用解耦、可复用的组件来构造界面。 轻量： ~24kb min+gzip，无依赖。 快速： 精确有效的异步批量 DOM 更新。 模块友好： 通过 NPM 或 Bower 安装，无缝融入你的工作流。 喜欢vue的理由 可扩展的数据绑定机制 原生对象即模型 简洁明了的 API 组件化 UI 构建 多个轻量库搭配使用 vue起手式vue-cli脚手架: 官网介绍安装 vue-cli安装 下拉到命令行全局安装vue-cli npm install -g vue-cli 或 npm install –global vue-cli 初始化项目 vue init webpack vuedemo(你的项目名) 会出现提问，一路回车即可。随后 $ cd vuedemo(你的项目名) 安装webpack依赖 npm install npm镜像一般要换成淘宝镜像 npm install -g cnpm –registry=http://registry.npm.taobao.org 安装完成后,把项目跑起来: npm run dev 如上四个命令，就会自动打开一个浏览器窗口，你的第一个vue项目就跑起来。你编写的代码的时候，ctrl+s浏览器窗口会自动刷新 项目完成后，可以打包成线上包，指令为 npm run build","tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/tags/vue-js/"},{"name":"前端小镇","slug":"前端小镇","permalink":"http://yoursite.com/tags/前端小镇/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]},{"title":"移动端踩坑实践","date":"2017-02-24T06:52:59.000Z","path":"2017/02/24/你不懂js_类型/","text":"基础的牢固对于阅读源码等有很大的帮助 typeof 的 “安全防御行为”123if (typeof atob === \"undefined\") &#123; atob = function() &#123; /*..*/ &#125;;&#125; 此处如果在if语句中用var变量声明atob，则会造成变量提升，即使没有走if语句。(参见作用域与闭包)123var a = trueif(!a) &#123;e= 2&#125;else &#123;c = 1&#125; 打印e 会输出 ReferenceError: e is not defined而如果123var a = trueif(!a) &#123;var e= 2&#125;else &#123;c = 1&#125; 输出的为undefined 变量被提升了","tags":[{"name":"你不懂js","slug":"你不懂js","permalink":"http://yoursite.com/tags/你不懂js/"}]},{"title":"移动端踩坑实践","date":"2017-02-24T06:52:59.000Z","path":"2017/02/24/移动端踩坑实践/","text":"去年十一月份接手了一个项目,移动端webapp,已经经历了长达四个月的开发,迭代,维护。特此记录下实践过程中的坑,方便以后查阅。如有不对，请指正，谢谢！ ios端关于date() 兼容性问题 项目中有一关于返回的时间与某一时间戳对比的问题,时间戳返回的为数字,而时间返回的是 ‘2017-02-24 14:58:32’形式用,最开始使用的方法为: 1var dTime = (new Date(time)).getTime(); 但实际过程中发现ios端对此返回的是NaN.解决方案为: 1dTime = dTime.replace(/\\-/g, \"/\"); Android,Ios共用的是此种形式: 1var date =new Date(\"2016/05/31 08:00\"); 所以使用正则调整为两者皆可的形式即可。 Html5日历控件赋值问题 HTML5中新增了日历控件，如果将控件的type=“datetime-local”，如果是Chrome，控件的日期显示格式是2016/05/30 08:00 ，如果是Safari，日期的显示格式是：2016-05-31T08:00，当我们用jQuery取值赋值的时候，就必须用这种方式才能赋值： 12let dTime = '2016-05-30T08:30'$(\"#timeDate\").val(dTime) 抽空继续总结，未完待续…","tags":[{"name":"前端小镇","slug":"前端小镇","permalink":"http://yoursite.com/tags/前端小镇/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"iframe父子页面通信实现","date":"2017-02-23T14:11:08.000Z","path":"2017/02/23/iframe父子页面通信实现/","text":"近来有一需求，即在PC端erp内嵌移动官网，通过iframe来实现嵌套的，但是又需要实现在父页面添加prev，next按钮，最后通过设置页面简单路由的方式来解决了。借此，系统学了下iframe父子页面通信。 一、 同域下父子页面通信 先来看具体实现 parent.html 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\"&gt; function say()&#123; alert(\"parent.html\"); &#125; function callChild()&#123; myFrame.window.say(); myFrame.window.document.getElementById(\"button\").value=\"调用结束\"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=\"button\" type=\"button\" value=\"调用child.html中的函数say()\" onclick=\"callChild()\"/&gt; &lt;iframe name=\"myFrame\" src=\"child.html\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 未完待续…","tags":[{"name":"iframe","slug":"iframe","permalink":"http://yoursite.com/tags/iframe/"},{"name":"router","slug":"router","permalink":"http://yoursite.com/tags/router/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]}]